//
//  These tests were generated by Gemini
//

#include "gtest/gtest.h"
#include "rbtree.hpp"

// Basic test to ensure the tree can be created and destroy, and empty tree operations.
TEST(RBTreeBasicTest, ConstructorAndDestructor)
{
    RBTree tree;
    // An empty tree should have a null root.
    ASSERT_EQ(tree.root, nullptr);
}

// Test simple insertion into an empty tree.
TEST(RBTreeInsertTest, InsertIntoEmptyTree)
{
    RBTree tree;
    Node* inserted_node = tree.Insert(10);

    ASSERT_NE(inserted_node, nullptr);
    ASSERT_EQ(tree.root, inserted_node);
    ASSERT_EQ(tree.root->data, 10);
    ASSERT_EQ(tree.root->color, BLACK); // Root must be black
    ASSERT_EQ(tree.root->parent, nullptr);
}

// Test that duplicate insertions return nullptr.
TEST(RBTreeInsertTest, DuplicateInsertion)
{
    RBTree tree;
    tree.Insert(10);
    Node* duplicate_node = tree.Insert(10);

    ASSERT_EQ(duplicate_node, nullptr); // Should return nullptr for duplicate
    ASSERT_EQ(tree.root->data, 10); // Tree should still contain the original node
}

// Test inserting multiple nodes and checking their parent/child relationships and colors (initial, simple check)
TEST(RBTreeInsertTest, MultipleInsertionsSimpleStructure)
{
    RBTree tree;
    tree.Insert(50);
    tree.Insert(30);
    tree.Insert(70);

    // For a simple sequence like 50, 30, 70, the tree should look like this (before full fixInsert logic):
    //      50(B)
    //     /   \
    //   30(R)  70(R)
    // (colors might change after fixInsert, this is a basic check)

    ASSERT_NE(tree.root, nullptr);
    ASSERT_EQ(tree.root->data, 50);
    ASSERT_EQ(tree.root->color, BLACK);

    ASSERT_NE(tree.root->left, nullptr);
    ASSERT_EQ(tree.root->left->data, 30);
    // The color of 30 will initially be RED. fixInsert will rebalance.
    // For now, we'll just check parent/child linkage.
    ASSERT_EQ(tree.root->left->parent, tree.root);

    ASSERT_NE(tree.root->right, nullptr);
    ASSERT_EQ(tree.root->right->data, 70);
    // The color of 70 will initially be RED. fixInsert will rebalance.
    // For now, we'll just check parent/child linkage.
    ASSERT_EQ(tree.root->right->parent, tree.root);

    // Test a search for existing nodes
    ASSERT_NE(tree.Search(30), nullptr);
    ASSERT_EQ(tree.Search(30)->data, 30);
    ASSERT_NE(tree.Search(70), nullptr);
    ASSERT_EQ(tree.Search(70)->data, 70);

    // Test search for a non-existing node
    ASSERT_EQ(tree.Search(99), nullptr);
}


// NOTE: More comprehensive tests for RBTree properties (black-height, no consecutive reds)
// will require a fully implemented fixInsert and its helper rotations.
// These are just initial sanity checks.
