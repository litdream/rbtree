#include "rbtree.hpp"

// Doxygen document generated by Gemini.
//


/**
 * @brief Constructs an empty Red-Black Tree.
 */
RBTree::RBTree() : root(nullptr) {
}

/**
 * @brief Destroys the Red-Black Tree, deallocating all nodes.
 */
RBTree::~RBTree() {
    // Hmm... Deletion dilema!!
    //   I will just delete it, for now,
    //   assuming, my RBTree is only for educational purpose.

    // TODO: implement deleteTree()
    // deleteTree( root);   // recursive deletion.

}


/**
 * @brief Searches for a node with the given key in the Red-Black Tree.
 *
 * @param key The integer key to search for.
 * @return A pointer to the Node if found, nullptr otherwise.
 */
Node *
RBTree::Search(int key) const {
    Node *cur = root;
    while (cur != nullptr) {
        if (cur->data == key)
            return cur;
        else if (key < cur->data)
            cur = cur->left;
        else
            cur = cur->right;
    }
    return cur;
}

Node *
RBTree::Insert(int key) {
    if (root == nullptr) {
        root = new Node(key, BLACK);
        return root;
    }

    if (Search(key)) {
        // Already exists!
        return nullptr;
    }

    // BST insert logic.
    Node *new_node = new Node(key);     // By default, it's RED.
    Node *cur = root;
    Node *par = nullptr;
    while (cur != nullptr) {
        par = cur;
        cur = ( key < cur->data ? cur->left : cur->right );
    }
    new_node->parent = par;

    key < par->data ?   \
        par->left = new_node : \
        par->right = new_node;

    // Restore RedBlack Tree Rule.
    fixInsert(new_node);
    return new_node;
}


void
RBTree::fixInsert(Node *&node) {
    // first of all,  I(&node) am RED, because I was just inserted,
    //   and came here to fix tree-properties.
    //
    // also, I(&node) has a parent.  Because, root-insertion is already
    //   returned away!
    //
    Node *parent = nullptr;
    Node *grandpar = nullptr;


    // The fix loop:
    // Since I'm RED, tracing up the parents, if there is any consecutive RED
    //
    while ( (node != root) &&
            (node->color == RED) &&
            (node->parent->color == RED) ) {

        // Okay, found the RED-RED sequence.
        //
        parent = node->parent;
        grandpar = parent->parent;
        //
        //  ^ This is safe, because of the rule:  root is "BLACK"
        //
        //  - Think about Rust Compiler case.
        //     - Rust should use `if let Some()/ Else` Enum.  to make rustc happy.
        //


        // CASE A: The parent is the left child of grandpar
        //    - [Case document](rbtree-insert-fix-case.md)
        //    - NOTE:  RBTree is not Perfectly Balanced Tree, unlike AVL.
        //      - Therefore, accept, why we don't care height of mine/parent/uncle.
        //      - PRE: The previous fix, should have left the Tree VALID.
        //
        if (parent == grandpar->left) {
            Node *uncle = grandpar->right;

            // Case 1: The uncle is also RED
            //  - Action:  Recolor parent, uncle, and grandpar.  Then move up the tree.
            //
            if (uncle != nullptr && uncle->color == RED) {
                grandpar->color = RED;
                parent->color = BLACK;
                uncle->color = BLACK;
                node = grandpar;    // we can skip to grandpar.
            } else {

                // Case 2: The uncle is BLACK, and 'node' is a right child. (Triangle case)
                //  - Action: left-rotate the parent to turn this into a line case (Case 3).
                //
                if (node == parent->right) {
                    rotateLeft(parent);
                    node = parent;
                    parent = node->parent;
                }

                // Case 3: The uncle is BLACK, and 'node' is a left child. (Line case)
                //  - Action: Recolor parent/grandparent and right-rotate the grandparent.
                //
                std::swap(parent->color, grandpar->color);
                rotateRight(grandpar);
                node = parent;

            }
        }
        // CASE B: The parent of 'node' is the right child of the grandparent.
        //  (Symmetrical to CASE A)
        //
        else {
            Node *uncle = grandpar->left;

            // Case 1: uncle is RED
            if ( (uncle != nullptr) && (uncle->color == RED)) {
                grandpar->color = RED;
                parent->color = BLACK;
                uncle->color = BLACK;
                node = grandpar;
            } else {

                // Case 2: uncle is BLACK, 'node' is a left child (Triangle)
                if (node == parent->left) {
                    rotateRight(parent);
                    node = parent;
                    parent = node->parent;
                }

                // Case 3: uncle is BLACK, 'node' is a right child. (Line)
                std::swap(parent->color, grandpar->color);
                rotateLeft(grandpar);
                node = parent;
            }
        }
    }
    root->color = BLACK;
}


// [document in here](rbtree-rotate-left-right.md)
//
void
RBTree::rotateLeft(Node *&x) {
    // y becomes the new root of the subtree.
    Node *y = x->right;

    // Some cut/ attach/ things will follow:
    //    - Detail: in the [doc](rbtree-rotate-left-right.md)
    //
    x->right = y->left;
    if (y->left != nullptr)
        y->left->parent = x;

    y->parent = x->parent;
    if (x->parent == nullptr)
        root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;

    y->left = x;
    x->parent = y;
}


// [document in here](rbtree-rotate-left-right.md)
//
void RBTree::rotateRight(Node *&y) {
    // x becomes the new root of the subtree.
    Node *x = y->left;

    // Some cut/ attach/ things will follow:
    //    - Detail: in the [doc](rbtree-rotate-left-right.md)
    //
    y->left = x->right;
    if (x->right != nullptr)
        x->right->parent = y;

    x->parent = y->parent;
    if (y->parent == nullptr)
        root = x;
    else if (y == y->parent->right)
        y->parent->right = x;
    else
        y->parent->left = x;

    x->right = y;
    y->parent = x;
}
