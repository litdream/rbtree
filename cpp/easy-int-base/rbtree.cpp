#include "rbtree.hpp"

// Doxygen document generated by Gemini.
//


/**
 * @brief Constructs an empty Red-Black Tree.
 */
RBTree::RBTree() : root(nullptr) {
}

/**
 * @brief Destroys the Red-Black Tree, deallocating all nodes.
 */
RBTree::~RBTree() {
    // Hmm... Deletion dilema!!
    //   I will just delete it, for now,
    //   assuming, my RBTree is only for educational purpose.

    // TODO: implement deleteTree()
    // deleteTree( root);   // recursive deletion.

}


/**
 * @brief Searches for a node with the given key in the Red-Black Tree.
 *
 * @param key The integer key to search for.
 * @return A pointer to the Node if found, nullptr otherwise.
 */
Node *
RBTree::Search(int key) const {
    Node *cur = root;
    while (cur != nullptr) {
        if (cur->data == key)
            return cur;
        else if (key < cur->data)
            cur = cur->left;
        else
            cur = cur->right;
    }
    return cur;
}

Node *
RBTree::Insert(int key) {
    if (root == nullptr) {
        root = new Node(key, BLACK);
        return root;
    }

    if (Search(key)) {
        // Already exists!
        return nullptr;
    }

    // BST insert logic.
    Node *new_node = new Node(key);     // By default, it's RED.
    Node *cur = root;
    Node *par = nullptr;
    while (cur != nullptr) {
        par = cur;
        cur = ( key < cur->data ? cur->left : cur->right );
    }
    new_node->parent = par;

    key < par->data ?   \
        par->left = new_node : \
        par->right = new_node;

    // Restore RedBlack Tree Rule.
    fixInsert(new_node);
    return new_node;
}


void
RBTree::fixInsert(Node *&node) {
    // first of all,  I(&node) am RED, because I was just inserted,
    //   and came here to fix tree-properties.
    //
    // also, I(&node) has a parent.  Because, root-insertion is already
    //   returned away!
    //
    Node *parent = nullptr;
    Node *grandpar = nullptr;


    // The fix loop:
    // Since I'm RED, tracing up the parents, if there is any consecutive RED
    //
    while ( (node != root) &&
            (node->color == RED) &&
            (node->parent->color == RED) ) {

        // Okay, found the RED-RED sequence.
        //
        parent = node->parent;
        grandpar = parent->parent;
        //
        //  ^ This is safe, because of the rule:  root is "BLACK"
        //
        //  - Think about Rust Compiler case.
        //     - Rust should use `if let Some()/ Else` Enum.  to make rustc happy.
        //


        // CASE A: The parent is the left child of grandpar
        //    - [Case document](rbtree-insert-fix-case.md)
        //    - NOTE:  RBTree is not Perfectly Balanced Tree, unlike AVL.
        //      - Therefore, accept, why we don't care height of mine/parent/uncle.
        //      - PRE: The previous fix, should have left the Tree VALID.
        //
        if (parent == grandpar->left) {
            Node *uncle = grandpar->right;

            // Case 1: The uncle is also RED
            //  - Action:  Recolor parent, uncle, and grandpar.  Then move up the tree.
            //
            if (uncle != nullptr && uncle->color == RED) {
                grandpar->color = RED;
                parent->color = BLACK;
                uncle->color = BLACK;
                node = grandpar;    // we can skip to grandpar.
            } else {

                // Case 2: The uncle is BLACK, and 'node' is a right child. (Triangle case)
                //  - Action: left-rotate the parent to turn this into a line case (Case 3).
                //
                if (node == parent->right) {
                    rotateLeft(parent);
                    node = parent;
                    parent = node->parent;
                }

                // Case 3: The uncle is BLACK, and 'node' is a left child. (Line case)
                //  - Action: Recolor parent/grandparent and right-rotate the grandparent.
                //
                std::swap(parent->color, grandpar->color);
                rotateRight(grandpar);
                node = parent;

            }
        }
        // CASE B: The parent of 'node' is the right child of the grandparent.
        //  (Symmetrical to CASE A)
        //
        else {
            Node *uncle = grandpar->left;

            // Case 1: uncle is RED
            if ( (uncle != nullptr) && (uncle->color == RED)) {
                grandpar->color = RED;
                parent->color = BLACK;
                uncle->color = BLACK;
                node = grandpar;
            } else {

                // Case 2: uncle is BLACK, 'node' is a left child (Triangle)
                if (node == parent->left) {
                    rotateRight(parent);
                    node = parent;
                    parent = node->parent;
                }

                // Case 3: uncle is BLACK, 'node' is a right child. (Line)
                std::swap(parent->color, grandpar->color);
                rotateLeft(grandpar);
                node = parent;
            }
        }
    }
    root->color = BLACK;
}


// [document in here](rbtree-rotate-left-right.md)
//
void
RBTree::rotateLeft(Node *&x) {
    // y becomes the new root of the subtree.
    Node *y = x->right;

    // Some cut/ attach/ things will follow:
    //    - Detail: in the [doc](rbtree-rotate-left-right.md)
    //
    x->right = y->left;
    if (y->left != nullptr)
        y->left->parent = x;

    y->parent = x->parent;
    if (x->parent == nullptr)
        root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;

    y->left = x;
    x->parent = y;
}


// [document in here](rbtree-rotate-left-right.md)
//
void RBTree::rotateRight(Node *&y) {
    // x becomes the new root of the subtree.
    Node *x = y->left;

    // Some cut/ attach/ things will follow:
    //    - Detail: in the [doc](rbtree-rotate-left-right.md)
    //
    y->left = x->right;
    if (x->right != nullptr)
        x->right->parent = y;

    x->parent = y->parent;
    if (y->parent == nullptr)
        root = x;
    else if (y == y->parent->right)
        y->parent->right = x;
    else
        y->parent->left = x;

    x->right = y;
    y->parent = x;
}


Node *
RBTree::Remove(int key) {
    Node *del_node = Search(key);
    if (del_node == nullptr) {
        return nullptr; // Node not found
    }

    Node *child_of_removed;
    Node *node_position = del_node;
    Color removed_node_original_color = node_position->color;

    if (del_node->left == nullptr) {
        child_of_removed = del_node->right;
        transplant(del_node, del_node->right);
    } else if (del_node->right == nullptr) {
        child_of_removed = del_node->left;
        transplant(del_node, del_node->left);
    } else {
        node_position = minValueNode(del_node->right);
        removed_node_original_color = node_position->color;
        child_of_removed = node_position->right;
        if (node_position->parent == del_node) {
            if (child_of_removed != nullptr) 
                child_of_removed->parent = node_position;
        } else {
            transplant(node_position, node_position->right);
            node_position->right = del_node->right;
            node_position->right->parent = node_position;
        }
        transplant(del_node, node_position);
        node_position->left = del_node->left;
        node_position->left->parent = node_position;
        node_position->color = del_node->color;
    }

    if (removed_node_original_color == BLACK) {
        if (child_of_removed != nullptr) fixDelete(child_of_removed);
    }

    delete del_node;
    return node_position; // Return the node that took the deleted node's place
}

/**
 * @brief Replaces one subtree as a child of its parent with another subtree.
 *
 * This function effectively replaces the node `u` in the tree with node `v`.
 * It updates the parent of `u` to point to `v` instead of `u`.
 * If `u` was the root, `v` becomes the new root.
 * It also sets the parent of `v` to `u`'s parent, if `v` is not nullptr.
 * This function is crucial for Red-Black Tree deletion, as it allows for
 * the removal of a node by replacing it with another (e.g., its child or successor).
 *
 * @param u A reference to the pointer of the node to be replaced.
 * @param v A reference to the pointer of the node that will replace `u`.
 */
void
RBTree::transplant(Node *&u, Node *&v) {
    if (u->parent == nullptr) {
        root = v;
    } else if (u == u->parent->left) {
        u->parent->left = v;
    } else {
        u->parent->right = v;
    }
    if (v != nullptr) {
        v->parent = u->parent;
    }
}

Node *
RBTree::minValueNode(Node *&node) {
    Node *cur = node;
    while (cur->left != nullptr) {
        cur = cur->left;
    }
    return cur;
}

/**
 * @brief Restores the Red-Black Tree properties after a node deletion.
 *
 * When a black node is removed from the tree, it violates the black-height
 * property (Property 5), which states that all paths from a node to its
 * descendant NIL leaves contain the same number of black nodes. This function
 * fixes the tree by performing a series of rotations and recolorings to
 * ensure all properties are maintained.
 *
 * @param node The node where the fixing process starts. This is the child of
 *             the physically removed node.
 */
void
RBTree::fixDelete(Node *&node) {
    while (node != root && (node == nullptr || node->color == BLACK)) {
        if (node == node->parent->left) {
            Node *sibling = node->parent->right; // sibling is node's sibling
            if (sibling->color == RED) {
                sibling->color = BLACK;
                node->parent->color = RED;
                rotateLeft(node->parent);
                sibling = node->parent->right;
            }
            if ((sibling->left == nullptr || sibling->left->color == BLACK) &&
                (sibling->right == nullptr || sibling->right->color == BLACK)) {
                sibling->color = RED;
                node = node->parent;
            } else {
                if (sibling->right == nullptr || sibling->right->color == BLACK) {
                    if (sibling->left != nullptr) sibling->left->color = BLACK;
                    sibling->color = RED;
                    rotateRight(sibling);
                    sibling = node->parent->right;
                }
                sibling->color = node->parent->color;
                node->parent->color = BLACK;
                if (sibling->right != nullptr) sibling->right->color = BLACK;
                rotateLeft(node->parent);
                node = root;
            }
        } else { // Symmetrical case: node is right child
            Node *sibling = node->parent->left; // sibling is node's sibling
            if (sibling->color == RED) {
                sibling->color = BLACK;
                node->parent->color = RED;
                rotateRight(node->parent);
                sibling = node->parent->left;
            }
            if ((sibling->right == nullptr || sibling->right->color == BLACK) &&
                (sibling->left == nullptr || sibling->left->color == BLACK)) {
                sibling->color = RED;
                node = node->parent;
            } else {
                if (sibling->left == nullptr || sibling->left->color == BLACK) {
                    if (sibling->right != nullptr) sibling->right->color = BLACK;
                    sibling->color = RED;
                    rotateLeft(sibling);
                    sibling = node->parent->left;
                }
                sibling->color = node->parent->color;
                node->parent->color = BLACK;
                if (sibling->left != nullptr) sibling->left->color = BLACK;
                rotateRight(node->parent);
                node = root;
            }
        }
    }
    if (node != nullptr) node->color = BLACK;
}

